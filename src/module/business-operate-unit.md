# 业务操作单元

业务操作单元就是一个不可再分的业务操作，是站在最终用户的视角划分的。
比如采购订单业务，新录入一个采购订单、查看一个采购订单、修改一个采购订单、删除一个采购订单、查询采购订单列表等。
这些业务操作不可再分，可一起组合出一个业务场景。

如何描述一个业务操作，并从编码的视角做拆分，然后跟单位代码块关联，然后按照一定的规则组织单位代码块。

以采购订单为例，考虑如何描述业务操作，以及业务操作之间的关系。

先描述交互过程。

梳理明白后，能支持以业务操作单元为单位增加代码与删除代码。
将代码块之间的关系勾连起来，从业务视角审视。

以下设计基于这样一个事实，就是一个业务操作由多个代码块支撑，只要是某一种业务操作，必然离不开这些代码块。
一个代码块下由一或多个源码文件下的一或多个代码段组成。


这里定义的是接口或抽象层，不是具体实现，因此可对应多套实现。

## 业务操作与代码块关系

先有业务操作，还是先有代码块？应该是先有业务操作。这个先后顺序很重要。

即因为有了这个业务操作，所以才需要相应的代码块支撑，代码块是为了更好的表达业务。
而不是先把代码块设计好，然后再跟业务操作关联起来，只要是某类业务操作，必然需要某些代码块，关键是找出这个关系。

## 原则

1. 每一个操作中会有相同的代码段，都要完整的列出来，不能假设某一个前置操作肯定存在，而不梳理重复的代码块
2. 明确操作之间的强依赖，即没有前者，就不能做后者

## 采购订单

为每个操作编号。

### 查询采购订单列表

id = query-{业务实体名}

交互过程：

1. 用户输入查询条件
2. 用户点击查询按钮
3. 向服务器端传入查询条件并返回结果
4. 返回结果绑定到数据表格上


借用 vitest 中的 `data-testid` 属性，为前端每个代码块设置唯一标识。

UI 可分三部分

1. 输入参数的面板
2. 交互组件或区域
3. 接收返回结果的组件

下载也有三部分

1. 输入参数的面板，可以没有
2. 按钮
3. 文件

代码块：

1. UI
   1. 输入参数面板，id = {操作id,query}-param
   2. 查询按钮，id = query-button
   3. 数据表格，id = query-result
2. 数据
   1. queryParam 输入参数
   2. list 返回的数据列表
   3. page 分页信息
   4. 数据权限，按角色划分，需求的源头在这里，service 层是实现细节
3. 操作
   1. api
4. Controller - list
   1. 分页
   2. 调用 service
5. Service - selectXXList(param)
   1. 数据权限（可选）
   2. 调用 mapper
6. Mapper - selectXXList(param)
   1. mapper 接口
   2. mapper xml，数据权限
7. Domain
8. Liquibase - 建表脚本
9. Liquibase - 为角色设置数据权限

查询条件面板

触发组件（通常是按钮）

数据表格

对每个 UI 块单独定义，然后可多处引用。

这里主要是组织 UI 块，而不是定义 UI 块。

### 新增一个采购订单

id = add-{业务实体名}

交互过程：

1. 用户点击新增按钮
2. 弹出表单对话框
3. 用户在表单中录入数据
4. 用户点击保存按钮
5. 向服务器端传入数据并返回结果
6. 如果保存失败，返回提示信息，不关闭对话框
7. 如果保存成功，返回提示信息，关闭对话框，并刷新列表

代码块：

1. UI
   1. 新增按钮，id = {操作id,add}-to-new-button
   2. 容器，id = add-form-container，如对话框
   3. form 表单，id = add-form-xx
   4. 保存按钮
   5. 取消按钮
   6. 删除按钮
2. 数据
   1. xxModel，用于新增与修改
   2. 容器是否可见
   3. 字段级数据校验，逐个字段描述
3. 操作
   1. 保存 api
   2. 取消
   3. 删除 api - 指向【删除一个采购订单】操作，此处不是源头
4. Controller - insertXXX
   1. 开启校验
   2. 校验
      1. 唯一约束触发的是否被占用校验，全表级
      2. 状态进展校验(还没有想明白)
   3. 补充数据
      1. 创建人
      2. 创建时间
   4. 调用 service
5. Service - insertXX(param)
   1. 事务注解
   2. 调用 mapper
6. Mapper - insertXX(param)
   1. mapper 接口
   2. mapper xml
7. Domain - 可在 list 或此处 中创建
   1. 不能为空校验 - 补充
   2. 单据等字段加 trim - 补充
8. Liquibase - 建表脚本(确认是否已存在)

### 查询一个采购订单

id = view-{xxx}

交互过程：

1. 用户在数据表格中双击一行记录
2. 弹出表单对话框
3. 向服务器端传入数据并返回结果
4. 将结果绑定到表单上

代码块：

1. UI
   1. 数据表格中的行，id = `数据表格的id:row:dblclick`，冒号后面跟 `row` 表示行级操作，再跟 `dblclick` 表示双击事件
   2. 容器，id = add-form-container，如对话框，（此处又引用一遍）
   3. form 表单，id = add-form-xx
2. 数据
   1. xxModel，用于查看
   2. 容器是否可见
   3. 记录标识，是输入参数
3. 操作
   1. 查一条数据 api
4. Controller - selectXXXById
   1. 调用 service
5. Service - selectXXById
   1. 调用 mapper
6. Mapper - selectXXById
   1. mapper 接口
   2. mapper xml
7. Domain - 可在 list 或此处 中创建
8. Liquibase - 建表脚本(确认是否已存在)

### 修改一个采购订单

交互过程：

1. 在查询一个采购订单的基础上
2. 用户修改数据
3. 用户点击保存按钮
4. 如果修改失败，返回提示信息，不关闭对话框
5. 如果修改成功，返回提示信息，关闭对话框，并刷新列表

代码块：

1. UI
   1. 容器，id = add-form-container，如对话框
   2. form 表单，id = add-form-xx
   3. 保存按钮
2. 数据
   1. xxModel，用于修改
   2. 容器是否可见，修改完成后关闭（有些场景也不需要关闭）
   3. 字段级数据校验，逐个字段描述
3. 操作
   1. 修改 api
   2. 刷新表格
   3. 关闭容器
4. Controller - updateXXX
   1. 开启校验
   2. 校验
      1. 唯一约束触发的是否被占用校验，全表级
      2. 状态进展校验(还没有想明白)
   3. 补充数据
      1. 创建人
      2. 创建时间
   4. 调用 service
5. Service - updateXXX(param)
   1. 事务注解
   2. 调用 mapper
6. Mapper - updateXXX(param)
   1. mapper 接口
   2. mapper xml
7. Domain - 可在 list 或此处 中创建
   1. 不能为空校验 - 补充
   2. 单据等字段加 trim - 补充
8. Liquibase - 建表脚本(确认是否已存在)

### 删除一个采购订单

交互过程：

在列表中删除

1. 用户点击行上的删除按钮
2. 让用户确认是否删除
3. 用户确定要删除，关闭确认框，向服务器端传入数据并返回结果
   1. 删除功能，则返回提示信息，并刷新列表
   2. 删除失败，则返回提示信息
4. 用户确定不删除，关闭确认框

代码块：

1. UI
   1. 表格行里的删除按钮，id = {表格id}:row:delete-confirm
   2. 确认对话框
      1. 确定按钮，id = {表格id}:row:delete
      2. 取消按钮，不需要添加额外操作，可不取名
2. 数据
   1. id，临时变量，不需要定义页面级变量或页面级响应变量
3. 操作
   1. 删除 api
   2. 刷新表格
4. Controller - deleteXXX
   1. 校验
      1. 状态进展校验，如审核之后就不能删除（前提是定义了审核业务操作，这就又出现了一个新场景，即多了一个操作，就需要在其他操作中加入约束代码等）
      2. 被引用则不能删除
   2. 调用 service
5. Service - deleteXXX(id)
   1. 事务注解
   2. 调用 mapper
6. Mapper - deleteXXX(id)
   1. mapper 接口
   2. mapper xml
7. Liquibase - 建表脚本(确认是否已存在)

交互

在详情面板中删除

1. 在查询一个采购订单的基础上
2. 用户点击删除按钮
3. 让用户确认是否要删除
4. 用户确定要删除，关闭确认框，向服务器端传入数据并返回结果
   1. 删除功能，则返回提示信息，并刷新列表
   2. 删除失败，则返回提示信息
5. 用户确定不删除，关闭确认框

代码块：

1. UI
   1. form表单中的删除按钮，id = {form id}:delete-confirm
   2. 确认对话框
      1. 确定按钮，id = {form id}:delete
      2. 取消按钮，不需要添加额外操作，可不取名
2. 数据
   1. id，临时变量，不需要定义页面级变量或页面级响应变量
3. 操作
   1. 删除 api
   2. 关闭 form 表单
   3. 刷新表格
4. Controller - deleteXXX
   1. 校验
      1. 状态进展校验，如审核之后就不能删除（前提是定义了审核业务操作，这就又出现了一个新场景，即多了一个操作，就需要在其他操作中加入约束代码等）
      2. 被引用则不能删除
   2. 调用 service
5. Service - deleteXXX(id)
   1. 事务注解
   2. 调用 mapper
6. Mapper - deleteXXX(id)
   1. mapper 接口
   2. mapper xml
7. Liquibase - 建表脚本(确认是否已存在)




面板，操作等都单独定义，互相引用。

素材单独定义，然后使用业务操作将这些素材按需关联起来，即业务操作的关联也单独定义。


描述在方法中增加什么操作（这个操作对应一块代码，这个代码块的逻辑是明确的、唯一的）

新增的方法块，删除的方法块等都是固定的。不是以方法为最小单元，而是以方法中的代码块为最小单元，这个代码块的职能是明确的。


## 代码块

前端

1. 类型
2. 变量
3. 面板
4. 函数

后端

1. 类型
2. 方法
3. 变量
4. 语句


## 最小单元

1. 代码块是代码的最小单元
2. 业务操作是业务视角的最小单元
3. 一个业务操作包含多个代码块

如何描述代码块、如何描述业务操作，如何描述业务操作与代码块之间的关系，以及如何描述业务场景与业务操作之间的关系，是重中之重。


变化度

1. 代码块是随着程序模块变化的
2. 业务操作的定义往往是稳定的


注意，不同的操作会复用代码块。


一个值要么是存起来的，要么是计算出来的，不可能凭空产生。即使是计算出来的，也要逐层找出是由哪些存储下来的值计算的，这些追溯关系要记录下来。
这样当一个表字段变化时，就能推演出影响到哪些地方。

怎么描述呢？



元素要定位出来，但元素具体怎么布局，比如操作按钮放在哪里，不在此处描述，在界面布局中定义的。

操作是定义到组件的事件上。

为每一类代码块定义唯一标识。

业务操作只跟代码块的名称关联，具体的代码块是一段代码逻辑加上输入参数，输出的代码块。